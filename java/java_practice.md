## 题目
1.类的初始化过程：
* 初始化父类的静态变量和静态代码块
* 初始化子类的静态变量和静态代码块
* 初始化父类的普通成员变量和代码块，再执行父类的构造函数
* 初始化子类的普通成员变量和代码块，再执行子类的构造函数

2.GB2312编码中，一个汉字占两个字节，Java中的char类型的16为Unicode字符，所以可以存GB2312编码下的一个汉字。

char类型在Java中是一个16位的Unicode字符类型,表示范围是从0到65535(十六进制为0x0000到0xFFFF)。

3.正则匹配
| 符号 | 描述 |
|------|------|
| \b   | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配 "never" 中的 "er"，但不匹配 "verb" 中的 "er"。 |
| \B   | 非字边界匹配。"er\B" 匹配 "verb" 中的 "er"，但不匹配 "never" 中的 "er"。 |
| \cx  | 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是 "c" 字符本身。 |
| \d   | 数字字符匹配。等效于 [0-9]。 |
| \D   | 非数字字符匹配。等效于 [^0-9]。 |
| \f   | 换页符匹配。等效于 \x0c 和 \cL。 |
| \n   | 换行符匹配。等效于 \x0a 和 \cJ。 |
| \r   | 匹配一个回车符。等效于 \x0d 和 \cM。 |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 |
| \S   | 匹配任何非空白字符。与 [^\f\n\r\t\v] 等效。 |
| \t   | 制表符匹配。与 \x09 和 \cI 等效。 |
| \v   | 垂直制表符匹配。与 \x0b 和 \cK 等效。 |
| \w   | 匹配任何字类字符，包括下划线。与 "[A-Za-z0-9_]" 等效。 |
| \W   | 与 \w 取反，匹配任何非单词字符。与 "[^A-Za-z0-9_]" 等效。 |

4.java中，List允许包含重复元素，Set不允许包含重复元素。并非所有Set都是无序的。HashSet是无序的，TreeSet是有序的，LinkedHashSet是按插入顺序排序的。

5.抽象类是is-a的关系，接口是has-a的关系。

6. 抽象类和接口的知识点
* 接口可以继承接口，而且可以继承多个接口，但是不能实现接口，因为接口中的方法全部是抽象的，无法实现； 
-> 如果是Java 7以及以前的版本，那么接口中可以包含的内容有：1. 常量；2. 抽象方法
-> 如果是Java 8，还可以额外包含有：3. 默认方法；4. 静态方法
-> 如果是Java 9，还可以额外包含有：5. 私有方法
* 普通类可以实现接口，并且可以实现多个接口，但是只能继承一个类，这个类可以是抽象类也可以是普通类，如果继承抽象类，必须实现抽象类中的所有抽象方法，否则这个普通类必须设置为抽象类； 
* 抽象类可以实现接口，可以继承具体类，可以继承抽象类，也可以继承有构造器的实体类。 
* 抽象类中可以有静态main方法；抽象类里可以没有抽象方法，没有抽象方法的抽象类就是不想让别人实例化它； 
* 抽象类可以有构造方法，只是不能直接创建抽象类的实例对象而已。在继承了抽象类的子类中通过super(参数列表)调用抽象类中的构造方法，可以用于实例化抽象类的字段。 
* 接口方法的修饰符使用有严格限制，主要是为了保持接口作为行为契约的纯粹性和公开性。在Java 8中，接口方法可以是public、default、static，但不能是private或protected。
* 抽象类更像是一个不完整的类,它可以包含构造方法、普通成员变量、抽象方法和普通方法。而接口更像是一个行为的规范,只能包含常量、抽象方法(Java 8前)、默认方法和静态方法(Java 8后)。

7. 常见的抽象类与接口的区别： 
* 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象； 
* 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现（java8中 接口可以有实现方法 使用default修饰）； 
* 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量； 
* 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类； 
* 抽象方法要被实现，所以不能是静态static的，也不能是私有private的，也不能被final修饰（试想一下，静态方法可以被类名直接调用，而类名直接调用一个没有实现的抽象方法没有意义）。 

8. java 垃圾回收机制
* Java堆内存采用分代结构，分为新生代（Young Generation）和老年代（Old Generation）。新生代进一步分为Eden区和两个Survivor区（S0和S1）。
* 虽然大多数新对象会在Eden区分配，但大对象（通过JVM参数-XX:PretenureSizeThreshold设置）会直接分配到老年代，避免在Eden区频繁复制。因此，对象并非“总是”在Eden区分配。
* 在Minor GC（YGC）时，若存活对象无法全部放入To Survivor区，超出的部分会直接晋升到老年代。
* 老年代内存使用率达到阈值时，并不直接触发Full GC。例如：
-> CMS收集器：当老年代使用率超过-XX:CMSInitiatingOccupancyFraction阈值时，触发的是并发标记周期（非Full GC），仅在并发失败时转为Full GC。
-> Parallel收集器：老年代空间不足时才会触发Full GC。
* Java垃圾回收器会自动回收不再使用的对象所占用的堆内存空间,而不是方法调用完成后的内存资源。方法调用结束后,其栈帧会自动从虚拟机栈中弹出,这个过程是由Java虚拟机(JVM)直接管理的,与垃圾回收器无关。

* 具体分析:
    1. 方法调用内存管理:
    - 每个方法调用都会在虚拟机栈中创建一个栈帧
    - 方法执行完毕后,栈帧自动弹出并释放相应的内存空间
- 这个过程是JVM自动完成的,不需要垃圾回收器参与

    2. 垃圾回收器的职责:
    - 主要负责回收堆内存中不再被引用的对象
    - 不负责处理虚拟机栈、本地方法栈等内存区域
    - 通过可达性分析等算法识别并回收垃圾对象


9. java的4类流程控制语句
循环语句：for，while，do-while
选择语句：if-else，switch
跳转语句：break，continue
异常处理语句：try-catch-finally，throw

10.java字符串
* 四个将两个字符串合并成一个字符串的函数

| 方法            | 线程安全 | 性能 | 适用场景 |
|-----------------|----------|------|----------|
| String.join()   | 是（底层同步） | 中  | 需分隔符的少量字符串合并 |
| String.concat() | 否       | 低  | 简单的两字符串合并 |
| StringBuilder   | 否       | 高  | 高频拼接（如循环中） |
| StringBuffer    | 是       | 中  | 多线程环境下的高频拼接 |
* equals()方法比较的是字符串的内容
* ==运算符比较的是对象的引用

11.jvm命令
* jmap：生成JVM堆转储快照（heap dump），并提供堆内存的详细信息，包括对象分布、内存使用率、垃圾收集器配置等。
* info：查看或修改JVM运行时参数（如系统属性、启动参数），不涉及内存映像。
* jhat：分析已生成的堆转储文件（如.hprof），提供HTTP服务展示内存分析结果，但本身不生成内存映像。
* jstat：监控JVM运行时统计信息（如GC次数、堆内存使用率），仅提供动态数据，不生成完整内存映像。
* JVM的内存配置参数
-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3

  -Xmx：表示虚拟机的最大可用内存， 

  -Xms表示虚拟机的最小可用内存 ，

  -Xmn表示年轻代大小。由一个Eden区与两个Survivor区组成。

   -XXSurvivorRatio=3，表示一个Eden区与一个Survivor区的比值为3：1. 总份数 = 3 (Eden) + 1 (Survivor1) + 1 (Survivor2) = 5份，每份大小 =5120 MB / 5 = 1024 MB，所以Survivor区总大小：1024 MB*2=2048M。


12. 变量初始化
在Java中，final变量(成员变量)必须在以下位置之一进行初始化：
* 声明时直接初始化
* 在构造方法中初始化
* 在初始化块中初始化

13. 线程的启动
* 当调用t.run()时,方法会在当前线程(main线程)中执行,而不是启动新线程。这相当于普通的方法调用。
* 使用t.start()方法。这样才会创建新的线程。

14.Collection接口定义的方法包括size()、containsAll()、remove()等，而compareTo()方法属于Comparable接口，并非Collection接口的方法。

15.被static修饰的方法中不能有this和super关键字，因为static方法被调用时，该类的对象可能还没有被创建，也就无法确定调用的是哪个对象。

16.不管使用Character.toString()还是String.valueOf(),它们都会保持字符的可读形式,而不会转换为ASCII码值。如果想要得到字符的ASCII码值,需要使用(int)强制类型转换。

17. HashMap和Hashtable
* HashMap和Hashtable都是基于哈希表实现的Map接口，都使用key-value方式存储和获取数据。
* HashMap是非同步的，适合单线程环境，性能较好；Hashtable是同步的，适合多线程环境，但性能相对较差。
* HashMap采用了fail-fast机制进行快速迭代，而Hashtable使用Enumeration进行迭代，相对较慢。
* HashMap允许null值作为key和value，而Hashtable不允许null值作为key和value。

18.java线程的状态
线程可以有6种状态：new、runnable、blocked、waiting、timed waiting、terminated

19.java中的锁
* 根据线程获取锁的抢占机制,锁可以分为公平锁和非公平锁。根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。
* ReadWriteLock允许一个资源可以被多线程同时进行读操作,ReentrantLock是以独占方式实现的。
* synchronized锁和ReentrantLock锁都可以锁重入。synchronized锁是非公平锁，而ReentrantLock可以通过修改参数来实现公平锁。synchronized不能被主动打断，ReentrantLock锁可以。synchronized不支持多个条件变量，而ReentrantLocK可以调用newCondition方法实现多个条件变量。

20.
* Java是纯面向对象语言，所有代码必须定义在类中，不存在独立的“过程”或“函数”。
* 方法必须隶属于类或对象，不能单独存在。
* 非静态方法属于实例成员（对象），而静态方法才属于类成员。
* 虽然Java方法必须属于类或对象，但调用方式与C/C++不同：Java需通过类名（静态方法）或对象（实例方法）调用。C/C++允许独立调用函数或过程。

21.java静态变量
* Java中静态变量只能在类主体中定义，不能在方法中定义。
* 静态变量属于类所有而不属于方法。  

22. 当比较引用类型时比较的是引用地址，而基本类型比较的是具体的值。在比较时要注意数据类型的匹配问题。

23.在Java中,finally块中的代码一定会执行,且会覆盖try或catch块中的返回值。执行顺序是:
* 首先执行try块中的代码
* 如果发生异常则执行catch块
* 最后一定会执行finally块
* 当try或catch块中的return语句被执行时，return值会被暂存，finally块中的代码不会改变这个返回值，但finally块中的代码一定会被执行。

    * finally块中的代码总是会执行,即使try或catch块中抛出了异常
    * 如果catch块中抛出新异常且未被捕获,则在finally块执行完后程序会终止
    * finally块后的代码只有在整个try-catch-finally结构正常执行完毕后才会执行。

24. java中的sleep和wait方法
* sleep是Thread类的静态方法，而wait是Object类的方法。
* sleep不会释放对象锁，而wait会释放对象锁。
* sleep使线程暂停执行指定时间，期间线程的监控状态保持不变，时间到后线程会自动恢复运行。
* wait进入等待池后，即使该对象调用了notify方法，等待的线程也不会自动获得对象锁并进入运行状态。而是要和其他竞争线程一起参与锁的竞争，只有竞争到锁才能继续执行。
* wait必须在同步块中使用，而sleep可以在任何地方使用。
* wait通常用于线程间协作，而sleep通常用于暂停线程执行
* wait后如果没有notify/notifyAll，线程会一直等待，而sleep会在指定时间后自动恢复。

25. Java多态的特性：
* 编译时多态：编译器根据引用类型决定可以调用哪些方法
* 运行时多态：如果方法被重写,则实际执行时根据对象的实际类型决定调用哪个版本的方法

26. Http相关接口
* 读取路径信息应该使用HttpServletRequest接口的方法,如getRequestURI()、getContextPath()、getServletPath()等。
* 设置HTTP头标，设置Cookie，输出返回数据使用HttpServletResponse接口的方法。
* 这体现了Servlet API中请求和响应职责的明确分工 - HttpServletRequest负责获取请求信息,HttpServletResponse负责生成响应。

27. 关于语句 A a = new A(); 的运行过程，正确的顺序是：
* 在栈内存分配变量 a 的空间（类型为 A 的引用变量，存储对象的地址）。
* 在堆内存分配存储空间（为 A 的对象分配内存）。
* 在分配好的堆内存空间实例化 A 对象（初始化成员变量并执行构造函数）。
* 将 a 变量指向分配的堆内存地址（引用变量 a 存储堆内存地址，指向对象）。
    * 关键分析：
    * 栈分配优先：声明 A a 时，栈内存会先分配空间给引用变量 a（此时 a 未指向任何对象）。
    * 堆分配与实例化：new A() 触发堆内存分配，随后在堆中完成对象初始化（包括默认值赋值和构造函数执行）。
    * 引用赋值最后：对象初始化完成后，堆内存地址才会赋给栈中的变量 a。

28.SDK(Software Development Kit)是软件开发工具包的统称,包含了开发某种软件需要的各种工具。

JDK(Java Development Kit)是Java开发工具包,包含了Java开发所需的编译器、调试器等开发工具,以及JRE。它是Java开发的标准工具集。

JRE(Java Runtime Environment)是Java运行环境,包含了Java虚拟机(JVM)、核心类库等运行Java程序所需的基本组件。

29.只有对变量的简单赋值(如x=1)是原子操作,不需要同步。而涉及到读取-修改-写回这样的复合操作,都需要通过同步机制(如synchronized、原子类等)来保证线程安全。这是因为复合操作在执行过程中可能被其他线程打断,导致数据不一致。

30.基本数据类型
* 从低到高可以进行自动类型转换
* 从高到低需要显式类型转换
* byte类型进行乘法运算会自动提升为int类型

31.java-web
* web.xml是Java Web应用程序的核心配置文件,它必须放在WEB-INF目录下。WEB-INF是一个特殊的目录,浏览器无法直接访问该目录下的任何资源,这样可以保护web应用的配置信息和内部资源的安全性。
* conf目录通常用于存放Tomcat服务器的配置文件,而不是Web应用的配置文件。
* lib目录是WEB-INF下用于存放Web应用所依赖的JAR包的目录。
* classes目录是WEB-INF下用于存放编译后的class文件和资源文件的目录。

32. java内部类
![java内部类](graph1.png)

33.volatile关键字
* volatile关键字是Java中用于保证线程安全的一种机制,主要用于保证变量在多线程环境下的可见性和有序性。
* volatile只能用于修饰变量,不能修饰方法和类。这是Java语法规定的使用范围。
* volatile不能完全替代锁机制。虽然volatile能保证可见性和有序性,但无法保证原子性,因此在需要互斥访问或原子操作的场景下,仍然需要使用synchronized等锁机制来实现线程安全。

34.一个类想要抛出自定义异常类，必须继承Throwable类或其子类

35.java泛型
* Java的虚拟机不支持泛型，所有的泛型在编译阶段都会被擦除，变成普通的类和方法。
* 在编译阶段，所有的泛型类型参数都会被擦除，替换为其边界类型（如果没有指定边界，则替换为Object）。
* 在创建泛型对象时明确指定类型参数是一个很好的实践。这样编译器可以在编译阶段就进行类型检查，避免运行时出现类型转换异常。
* 类型擦除是Java泛型的重要特性，但这并不意味着完全无法获取泛型的类型信息。通过反射机制，我们依然可以在运行时获取到泛型的实际类型参数。

36.Java字符编码和国际化
* Java中的char类型确实是使用UTF-16编码的,默认采用Big Endian字节序。每个char固定占用2个字节(16位),可以表示基本多语言平面(BMP)中的所有字符。
* ResourceBundle是Java国际化最常用的工具类,它可以根据不同的Locale加载相应的资源文件,实现应用程序的多语言支持。通过ResourceBundle可以方便地管理不同语言的文本资源。
* 字符占用的字节数与具体的编码方案有关。在UTF-8编码中,英文字符占1个字节,而中文字符通常占3个字节；在GBK编码中,英文字符占1个字节,中文字符占2个字节。
* 数据库编码与网页编码可以不同。只要在读取数据时正确指定编码方式进行解码,再按照网页编码重新编码,就可以正确显示。这种编码转换在程序中是很常见的操作。

37.java多行注释/* */可以嵌套单行注释//,但是多行注释不能嵌套多行注释

38.java枚举
* 枚举可以定义实例方法、实例变量和构造函数。
* 枚举不能被其他类继承，也不能继承其他类。
* 枚举是Java中的一种特殊数据类型，用于定义一组固定常量。
* 枚举可以包含构造函数，但必须为私有（默认隐式私有）。

39. throws关键字用于在方法声明中指明该方法可能抛出的检查型异常（非运行时异常）。这是一种异常声明机制，告知方法调用者需要处理这些可能的异常情况。

throw关键字用于在代码中显式地抛出一个异常对象。这是手动抛出异常的方式，可以抛出自定义的异常或系统预定义的异常。

40.类的构造函数
* 若未显式定义构造函数，Java编译器会默认生成无参构造函数。因此构造函数可以省略。
* 构造函数必须与类同名，但普通方法允许与类同名（需声明返回类型）。
* 构造函数在对象实例化（new）时自动调用。
* Java支持构造函数重载，一个类可定义多个参数不同的构造函数。
* 构造方法在代码块之后执行
* 构造方法用于对象初始化
* 构造方法在new对象时自动调用
* 构造方法没有返回值类型（不是void，而是完全没有）
* 构造方法的名称必须与类名相同

41.Java的I/O流可以分为:
* 字节流:以字节为单位处理数据,包括InputStream和OutputStream体系
* 字符流:以字符为单位处理数据,包括Reader和Writer体系

BufferedReader类读取字符串应该使用readLine()方法。read()方法是用来读取单个字符的，返回的是int类型的ASCII码值。如果要读取字符串，正确的方法是使用readLine()。

System.out实际上是PrintStream类的对象实例，而不是PrintWriter类的对象。print()和println()方法是由PrintStream类定义的。

FileInputStream确实是用于从文件读取数据的输入流，它是字节流的一种，可以使用new关键字创建对象。

File类中的mkdir()和mkdirs()方法都可以用来创建文件夹，其中：
- mkdir()方法用于创建单个目录
- mkdirs()方法用于创建多级目录，如果父目录不存在会自动创建父目录

42.java的体系结构

（1）Java编程语言:
- 是开发Java应用程序的基础
- 提供了简单、面向对象、分布式、健壮等特性
- 是程序员编写Java代码的直接工具

（2）Java类文件格式:
- 是源代码编译后的标准格式
- .class文件包含了字节码指令
- 实现了平台无关性的重要基础

（3）Java API:
- 提供了丰富的类库支持
- 包含了核心类库、扩展类库等
- 是开发Java应用程序的重要组件

（4）JVM(Java虚拟机):
- Java程序运行的平台
- 负责执行字节码
- 提供了内存管理、垃圾回收等机制

这四个部分紧密关联:
- 程序员使用Java语言编写代码
- 编译成类文件格式
- 调用Java API进行开发
- 最终在JVM上运行

43.在涉及不同数据类型运算时，较小精度的类型会自动提升为较大精度的类型，然后再进行运算。

44.类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。   

45.Vector:它是线程安全的动态数组实现,其所有方法都被synchronized修饰,在多线程环境下可以安全使用。

Hashtable:也是线程安全的,其所有方法都使用synchronized进行同步,可以在多线程环境下安全地进行键值对操作。

Stack:继承自Vector类,因此具有Vector的线程安全特性,其push和pop等操作都是同步的。

46.访问权限修饰符的正确使用规则：
* 外部类：只能用public或默认
* 成员内部类：可以使用所有四种访问修饰符（public、protected、private和默认）
* 局部内部类：不能使用任何访问修饰符
* 匿名内部类：不能使用任何访问修饰符

47. 在Java中,Integer类型在-128到127之间的数值会被缓存。当我们创建这个范围内的Integer对象时,实际上是从缓存池中取出对象,所以这些对象是同一个实例。而超出这个范围的数值则会创建新的对象。

48. 移位运算
- `>>` 是带符号右移，右移后左边补符号位（正数补0，负数补1）
- `>>>` 是无符号右移，右移后左边统一补0
- 每右移一位相当于除以2
- 如果是正数，`>>`和`>>>`的效果是一样的，都是补0

49. request
* request.getAttribute()方法是从request范围内获取存储对象的标准方法。在JavaWeb开发中,我们可以使用request.setAttribute()方法在request作用域中存储对象,然后通过getAttribute()方法获取这些对象。
* request.getRequestURL() - 该方法返回客户端请求的完整URL,而不是获取request范围内存储的对象。
* request.getParameter() - 该方法用于获取HTTP请求参数的值,通常用于获取表单提交的数据或URL中的查询参数,不是用来获取request范围内存储的对象。
* request.getWriter() - 该方法返回一个PrintWriter对象,用于向客户端发送字符响应,与获取request范围内的对象无关。

50. java异常
* Java的异常分为两大类：
    - 运行时异常(RuntimeException)：可以不做处理
    - 非运行时异常(编译时异常)：必须处理

* 非运行时异常的处理方式：
    - try-catch块捕获处理
    - throws关键字声明抛出
    - 两种方式必须选择其一，否则编译不通过

* 为什么必须处理非运行时异常：
    - 这类异常在编译阶段就能预见
    - 不处理可能导致严重后果
    - 编译器强制要求处理，否则报错

* 常见的非运行时异常例子：
    - IOException
    - SQLException
    - ClassNotFoundException

51. ServletConfig接口是由GenericServlet类默认实现的。GenericServlet是一个抽象类,它实现了Servlet和ServletConfig这两个接口,为所有Servlet提供了基础实现。

52. 线程相关
* 在多进程中，子进程通过fork()创建时会继承父进程的地址空间（包括堆和栈的副本，采用写时复制机制）。因此，子进程确实能获得父进程当时的堆和栈数据。
* 在多线程中，同一进程的线程共享全局变量、堆等数据，但每个线程拥有独立的栈空间。
* 线程的创建和切换开销远小于进程，因为线程共享进程资源（如内存），无需独立地址空间。
* 线程通过共享内存直接通信，无需跨进程的复杂机制（如管道、消息队列），速度更快。
* 线程切换仅需保存寄存器和栈指针，无需切换地址空间，因此切换成本更低。

53. TLS线程局部存储

TLS(线程局部存储)是一种特殊的存储机制，它为每个线程提供独立的变量副本。
* TLS是解决多线程访问冲突的一种技术。通过为每个线程提供独立的变量副本，避免了线程间的数据竞争，从而解决了并发访问冲突问题。
* TLS的核心特性。它会为每个线程创建并维护一个独立的变量副本，这些副本与特定线程绑定，其他线程无法访问。
* 虽然TLS为每个线程提供了独立的变量副本，但这并不意味着完全不需要同步。如果变量的操作涉及多个步骤，或者存在其他共享资源的访问，仍然可能需要同步机制。
* Java中的ThreadLocal类就是TLS技术的一个具体实现。它提供了创建线程局部变量的功能，使每个线程都拥有自己的变量副本。
* 总的来说，TLS是一种重要的并发编程技术，它通过为每个线程提供独立的变量副本来避免数据竞争。但要注意，它并不能解决所有的线程同步问题，在某些场景下仍需要使用其他同步机制。

54. 在Java中,静态方法不能直接访问非静态成员,这会导致编译错误。

55.byte类型是8位有符号整数,取值范围是-128到127。当b += a执行时:
* b的初始值是127(byte最大值)
* b += a 相当于 b = (byte)(b + a)
* 127 + 1 = 128,超出了byte的最大值127
* 由于byte是循环存储的,当超过127后会从最小值-128重新开始
* 所以最终b的值为-128

56. Java中所有异常和错误的基类是java.lang.Throwable，其中:
- Error和Exception都继承自Throwable
- RuntimeException是Exception的子类

57. 针对循环优化的主要方法包括强度削弱、删除归纳变量和代码外提,这些都是有效的循环优化技术。

58. JDK1.8中的ConcurrentHashMap采用了数组+链表+红黑树的复合数据结构,这是其内部存储的基本架构。当哈希冲突时,会首先使用链表来存储,当链表长度超过阈值(默认为8)时,链表会转换为红黑树,以提高检索效率。

